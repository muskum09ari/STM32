/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*TIM3 generates a PWM signal with a period of 1 second.
TIM4 captures the rising edges of the PWM using input capture mode.
The code calculates the frequency of the captured signal using the difference between successive capture values.
The result is stored in the fre variable.*/


// use debugger then switch->include variable->then f8 resume and then terminate added floar mcu seting float software

#include <stdint.h>
#include <STM32F405xx.h>

uint32_t current;
uint32_t last = 0;
uint32_t period;
float fre;

int main(void)
{
	   RCC->AHB1ENR |= (1<<2); // GPIOC Enable, Bit 2 of AHB1ENR port b
	   RCC->AHB1ENR |= (1<<1); // GPIOb Enable, Bit 2 of AHB1ENR port b

		RCC->APB1ENR |= (1<<1); // Enabled TIM3 as timer3 on 1
		RCC->APB1ENR |= (1<<2); // Enabled TIM4 as timer4 on 1

		GPIOC->MODER &=~(1<<12); // GPIOC pin12,13 clearing : 00 ->13 12
		GPIOC->MODER |= (1<<13); // 10 alternate fn output led on moder 12,13

		GPIOB->MODER &=~(1<<12); // GPIOb pin12,13 clearing : 00 ->13 12
		GPIOB->MODER |= (1<<13); // 10 alternate fn output led on moder 12,13


		GPIOC->AFR[0] &= ~(1 << 24);
		GPIOC->AFR[0] &= ~(1 << 26);
		GPIOC->AFR[0] &= ~(1 << 27);
	    GPIOC->AFR[0] |= (1 << 25);

	    GPIOB->AFR[0] &= ~(1 << 24);
	    GPIOB->AFR[0] &= ~(1 << 26);
	    GPIOB->AFR[0] &= ~(1 << 27);
	    GPIOB->AFR[0] |= (1 << 25);



	       //timer 3
	        TIM3->PSC = 16000-1; // 16 000 000 000/16000 = 10 000
	    	TIM3->ARR =  1000-1; // auto reload register
	    	TIM3->CCMR1 |= (1 << 4); // (6,5,4)=011 PWM MODE 1 pg 636 oc1m
	    	TIM3->CCMR1 |= (1 << 5);
	    	TIM3->CCMR1 &= ~(1 << 6);

	    	TIM3->CNT  = 0;
	    	TIM3->CCER |=(1<<0);// SET bit 0 as 1
	    	TIM3->CR1 |=(1<<0);// SET bit 0 to 1

	    	TIM4->CCR1=0;
	    	TIM4->PSC=16000-1;
	    	TIM4->CCMR1 &=~(7<<4); //frozen value
	    	TIM4->CCMR1=0x41; //fsampling
	    	TIM4->CCER=0X0B; // enable ch1 capture both edges
	    	TIM4->CR1 |=(1<<0);// SET bit 0 to 1

	    	 while (1) {
	    	      while (!(TIM4->SR & (1 << 1)));

	    	      current=TIM4->CCR1;

	    	      period = current - last;
	    	      last = current;
	    	      fre = (1000 / period); // Frequency in Hz

	    	 }

}
