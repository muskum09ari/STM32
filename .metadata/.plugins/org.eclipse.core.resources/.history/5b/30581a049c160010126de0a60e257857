#include <stdint.h>
#include <stdio.h>
#include "stm32f405xx.h"
#include "lcd.h"

#define ADC_BUF_LEN 1
uint16_t adc_buffer[ADC_BUF_LEN];
char buf[16];
float Vol;
volatile int dma_done = 0;


// === ADC1 Setup (Channel 11) ===
void adc1_init(void)
{
	GPIOC->MODER |= (1<<2);
		GPIOC->MODER |=(1<<3);

		//SET ENable for adc clock pg 187
		RCC->APB2ENR |=(1<<8);

		// Ensure ADC is disabled before configuration
		ADC1->CR2 &= ~(1<<0);

		// MAKE SEQUENCE REGISTER SQ1 BIT 0 TO 4 AS B bcz we are using channel 11 SO SQ1 0 TO 4  PG 423
		    ADC1->SQR3 &=~(1<<4);
			ADC1->SQR3 |=(1<<3);
			ADC1->SQR3 &=~(1<<2);
			ADC1->SQR3 |=(1<<1);
			ADC1->SQR3 |=(1<<0);

		// PAGE 422 SQR1 REGULAR CHANNEL SEQUANCE LENGTH FOR channel1 SO BIT has to be 11
		ADC1->SQR1 &=~(1<<20);
		ADC1->SQR1 &=~(1<<21);
		ADC1->SQR1 &=~(1<<22);
		ADC1->SQR1 &=~(1<<23);



		ADC1->CR1 |=(1<<8);// SCAN MODE ON
		// Set bits 0 to 4 as 11 (binary representation)
			//ADC1->CR1 |= (0xB);

		    ADC1->CR1 &=~(1<<4);
			ADC1->CR1 |=(1<<3);
			ADC1->CR1 &=~(1<<2);
			ADC1->CR1 |=(1<<1);
			ADC1->CR1 |=(1<<0);

			while(1){

					result = ADC_conversion();

				       lcd(0x80,0);
						lcd_string("CH11");

						single_print(result);

						Vol = (float)(result*3) /4095;
						sprintf(buf,"Vol:%.3f",Vol);
						lcd(0xC0,0);
						lcd_string(buf);
				}
}

// === DMA2 Stream0 Config for ADC1 ===
void dma2_init(void)
{
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;

    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
    while (DMA2_Stream0->CR & DMA_SxCR_EN); // Wait for disable

    DMA2_Stream0->PAR = (uint32_t)&ADC1->DR;
    DMA2_Stream0->M0AR = (uint32_t)adc_buffer;
    DMA2_Stream0->NDTR = ADC_BUF_LEN;

    DMA2_Stream0->CR = 0;
    DMA2_Stream0->CR |= (0 << 25);  // Channel 0
    DMA2_Stream0->CR |= DMA_SxCR_MINC;
    DMA2_Stream0->CR |= DMA_SxCR_CIRC;
    DMA2_Stream0->CR |= (1 << 13) | (1 << 11);  // 16-bit mem & peripheral
    DMA2_Stream0->CR |= DMA_SxCR_TCIE;          // Transfer complete interrupt

    DMA2_Stream0->FCR = 0;  // Direct mode (no FIFO)

    NVIC_EnableIRQ(DMA2_Stream0_IRQn);
    DMA2_Stream0->CR |= DMA_SxCR_EN;
}

// === ADC Start Conversion ===
void adc_start(void)
{
    ADC1->CR2 |= ADC_CR2_ADON;
    for (volatile int i = 0; i < 1000; i++);
    ADC1->CR2 |= ADC_CR2_SWSTART;
}

// === DMA IRQ Handler ===
void DMA2_Stream0_IRQHandler(void)
{
    if (DMA2->LISR & DMA_LISR_TCIF0)
    {
        DMA2->LIFCR |= DMA_LIFCR_CTCIF0;
        dma_done = 1;
    }
}

// === MAIN ===
int main(void)
{
    lcd_gpio_init();
    lcd_init();
    adc_gpio_init();
    adc1_init();
    dma2_init();
    adc_start();

    lcd(0x80, 0);
    lcd_string("ADC + DMA PC1");

    while (1)
    {
        if (dma_done)
        {
            dma_done = 0;

            lcd(0xC0, 0);
            single_print(adc_buffer[0]);

            Vol = (float)(adc_buffer[0] * 3.0f) / 4095.0f;
            sprintf(buf, "Vol:%.3f", Vol);
            lcd(0x94, 0);  // 2nd line second half
            lcd_string(buf);
        }
    }
}
