#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "lcd.h"

#define ADC_BUF_LEN 1
uint16_t adc_buffer[ADC_BUF_LEN];
char buf[16];
float Vol;
volatile int dma_done = 0;

void adc_gpio_init(void)
{
    // Enable GPIOC clock
    RCC->AHB1ENR |= (1<<2);// its PC1

    // Set PC1 to analog mode AS pc1 so pg281
    GPIOC->MODER |= (1<<2);  // 11: analog
    GPIOC->MODER |= (1<<3);
}

void adc1_init(void)
{
    // Enable ADC1 clock
    RCC->APB2ENR |= (1<<8);

    // Disable ADC before configuration
    ADC1->CR2 &= ~(1<<0);

    // Configure for channel 11 (PC1)
    ADC1->SQR3 = 11;  // 1st conversion in regular sequence is channel 11
    ADC1->SQR1 = 0;   // 1 conversion in the sequence

    // Enable scan mode
    ADC1->CR1 |= (1<<8);

    // Enable DMA mode, DMA continues for every conversion
    ADC1->CR2 |= ((1<<8) | (1<<9));

    // Enable continuous conversion mode
    ADC1->CR2 |= (1<<1);
}

void dma2_init(void)
{
    // Enable DMA2 clock
    RCC->AHB1ENR |= (1<<22);

    // Disable Stream 0 before configuration
    DMA2_Stream0->CR &= ~(1<<0);
    while (DMA2_Stream0->CR & (1<<0));  // Wait until disabled

    // Set peripheral address (ADC1->DR)
    DMA2_Stream0->PAR = (uint32_t)&ADC1->DR;

    // Set memory address
    DMA2_Stream0->M0AR = (uint32_t)adc_buffer;

    // Number of data items to transfer
    DMA2_Stream0->NDTR = ADC_BUF_LEN;

    // Channel 0
    DMA2_Stream0->CR &= ~((1<<25)|(1<<26)|(1<<27));

    // Memory increment mode
    DMA2_Stream0->CR |= (1<<10);

    // Circular mode
    DMA2_Stream0->CR |= (1<<8);

    // Peripheral and memory size: half-word (16-bit)
    DMA2_Stream0->CR |= ((1<<13)|(1<<14));
    DMA2_Stream0->CR |= ((1<<12)|(1<<11));

    // Transfer complete interrupt enable
    DMA2_Stream0->CR |= (1<<4);

    // Direct mode (no FIFO)
    DMA2_Stream0->FCR = 0;

    // Enable interrupt in NVIC
    NVIC_EnableIRQ(DMA2_Stream0_IRQn);

    // Enable the stream
    DMA2_Stream0->CR |= (1<<0);
}

void adc_start(void)
{
    ADC1->CR2 |= (1<<0);     // Enable ADC
    for (volatile int i = 0; i < 1000; i++);  // Short delay
    ADC1->CR2 |= (1<<30);  // Start conversion
}

// DMA2 Stream0 interrupt handler
void DMA2_Stream0_IRQHandler(void)
{
    if (DMA2->LISR & (1<<5))
    {
        DMA2->LIFCR |= (1<<5);
        dma_done = 1;
    }
}

int main(void)
{
    lcd_gpio_init();
    lcd_init();
    adc_gpio_init();
    adc1_init();
    dma2_init();
    adc_start();

    lcd(0x80, 0);
    lcd_string("ADC + DMA PC1");

    while (1)
    {
        if (dma_done)
        {
            dma_done = 0;

            lcd(0xC0, 0);
            single_print(adc_buffer[0]);

            Vol = (float)(adc_buffer[0]) * 3.0f / 4095.0f;
            sprintf(buf, "Vol:%.3f", Vol);
            lcd(0x94, 0);
            lcd_string(buf);
        }
    }
}
