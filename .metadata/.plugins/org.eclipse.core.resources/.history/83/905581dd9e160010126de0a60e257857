#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "lcd.h"

#define ADC_BUF_LEN 1
uint16_t adc_buffer[ADC_BUF_LEN];
char buf[16];
float Vol;
volatile int dma_done = 0;

void adc_gpio_init(void)
{
    // Enable GPIOC clock
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;

    // Set PC1 to analog mode
    GPIOC->MODER |= GPIO_MODER_MODE1;  // 11: analog
}

void adc1_init(void)
{
    // Enable ADC1 clock
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

    // Disable ADC before configuration
    ADC1->CR2 &= ~ADC_CR2_ADON;

    // Configure for channel 11 (PC1)
    ADC1->SQR3 = 11;  // 1st conversion in regular sequence is channel 11
    ADC1->SQR1 = 0;   // 1 conversion in the sequence

    // Enable scan mode
    ADC1->CR1 |= ADC_CR1_SCAN;

    // Enable DMA mode, DMA continues for every conversion
    ADC1->CR2 |= ADC_CR2_DMA | ADC_CR2_DDS;

    // Enable continuous conversion mode
    ADC1->CR2 |= ADC_CR2_CONT;
}

void dma2_init(void)
{
    // Enable DMA2 clock
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;

    // Disable Stream 0 before configuration
    DMA2_Stream0->CR &= ~DMA_SxCR_EN;
    while (DMA2_Stream0->CR & DMA_SxCR_EN);  // Wait until disabled

    // Set peripheral address (ADC1->DR)
    DMA2_Stream0->PAR = (uint32_t)&ADC1->DR;

    // Set memory address
    DMA2_Stream0->M0AR = (uint32_t)adc_buffer;

    // Number of data items to transfer
    DMA2_Stream0->NDTR = ADC_BUF_LEN;

    // Channel 0
    DMA2_Stream0->CR &= ~DMA_SxCR_CHSEL;

    // Memory increment mode
    DMA2_Stream0->CR |= DMA_SxCR_MINC;

    // Circular mode
    DMA2_Stream0->CR |= DMA_SxCR_CIRC;

    // Peripheral and memory size: half-word (16-bit)
    DMA2_Stream0->CR |= DMA_SxCR_MSIZE_0;
    DMA2_Stream0->CR |= DMA_SxCR_PSIZE_0;

    // Transfer complete interrupt enable
    DMA2_Stream0->CR |= DMA_SxCR_TCIE;

    // Direct mode (no FIFO)
    DMA2_Stream0->FCR = 0;

    // Enable interrupt in NVIC
    NVIC_EnableIRQ(DMA2_Stream0_IRQn);

    // Enable the stream
    DMA2_Stream0->CR |= DMA_SxCR_EN;
}

void adc_start(void)
{
    ADC1->CR2 |= ADC_CR2_ADON;     // Enable ADC
    for (volatile int i = 0; i < 1000; i++);  // Short delay
    ADC1->CR2 |= ADC_CR2_SWSTART;  // Start conversion
}

// DMA2 Stream0 interrupt handler
void DMA2_Stream0_IRQHandler(void)
{
    if (DMA2->LISR & DMA_LISR_TCIF0)
    {
        DMA2->LIFCR |= DMA_LIFCR_CTCIF0;
        dma_done = 1;
    }
}

int main(void)
{
    lcd_gpio_init();
    lcd_init();
    adc_gpio_init();
    adc1_init();
    dma2_init();
    adc_start();

    lcd(0x80, 0);
    lcd_string("ADC + DMA PC1");

    while (1)
    {
        if (dma_done)
        {
            dma_done = 0;

            lcd(0xC0, 0);
            single_print(adc_buffer[0]);

            Vol = (float)(adc_buffer[0]) * 3.0f / 4095.0f;
            sprintf(buf, "Vol:%.3f", Vol);
            lcd(0x94, 0);
            lcd_string(buf);
        }
    }
}
