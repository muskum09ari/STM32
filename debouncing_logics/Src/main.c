/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// arpit logic code

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  //#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdint.h>

// RCC register (peripheral clock enable)
uint32_t *RCC_AHB1ENR = (uint32_t*)0x40023830; // RCC AHB1 Peripheral Clock Enable Register

// GPIOC registers (for LEDs)
uint32_t *GPIOC_MODER = (uint32_t*)0x40020800;  // GPIOC Mode Register
uint32_t *GPIOC_ODR = (uint32_t*)0x40020814;    // GPIOC Output Data Register

// GPIOB registers (for Switches)
uint32_t *GPIOB_IDR = (uint32_t*)0x40020410;    // GPIOB Input Data Register (for switches)
uint32_t *GPIOB_ODR = (uint32_t*)0x40020414;    // GPIOB Output Data Register
uint32_t *GPIOB_MODER = (uint32_t*)0x40020400;   // GPIOB Mode Register

// GPIOA registers (for Switches)
uint32_t *GPIOA_MODER = (uint32_t*)0x40020000;   // GPIOA Mode Register
uint32_t *GPIOA_IDR = (uint32_t*)0x40020010;     // GPIOA Input Data Register (for PA15 switch)

// Debounce delay function
void delay(int count)
{
    for (int i = 0; i < count; i++) {
        __asm("NOP"); // No-operation instruction to create a delay
    }
}

int main(void)
{
    // Enable GPIOB, GPIOC, GPIOA clocks
    *RCC_AHB1ENR |= (1 << 2);  // Enable GPIOC clock (for LEDs)
    *RCC_AHB1ENR |= (1 << 1);  // Enable GPIOB clock (for switches)
    *RCC_AHB1ENR |= (1 << 0);  // Enable GPIOA clock (for switches)

    // Configure PC6, PB13, PB14, PB15 as output for LEDs
    *GPIOC_MODER |= (1 << 12);  // Set PC6 to output mode
    *GPIOC_MODER &= ~(1 << 13); // Clear bit 13 to configure PC6 as output

    *GPIOB_MODER |= (1 << 26);  // Set PB13 to output mode
    *GPIOB_MODER &= ~(1 << 27); // Clear bit 27 to configure PB13 as output

    *GPIOB_MODER |= (1 << 28);  // Set PB14 to output mode
    *GPIOB_MODER &= ~(1 << 29); // Clear bit 29 to configure PB14 as output

    *GPIOB_MODER |= (1 << 30);  // Set PB15 to output mode
    *GPIOB_MODER &= ~(1 << 31); // Clear bit 31 to configure PB15 as output

    // Configure PB7, PB3, PB4, PA15 as input for switches
    *GPIOB_MODER &= ~(3 << 14); // Set PB7 to input mode
    *GPIOB_MODER &= ~(3 << 6);  // Set PB3 to input mode
    *GPIOB_MODER &= ~(3 << 8);  // Set PB4 to input mode
    *GPIOA_MODER &=~(3 << 30); // Set PA15 to input mode

    // Initial LED state (all OFF)
    *GPIOC_ODR &= ~(1 << 6);  // LED 1 OFF (PC6)
    *GPIOB_ODR &= ~(1 << 13); // LED 2 OFF (PB13)
    *GPIOB_ODR &= ~(1 << 14); // LED 3 OFF (PB14)
    *GPIOB_ODR &= ~(1 << 15); // LED 4 OFF (PB15)

    // State variables for LEDs
    int led_state[4] = {0, 0, 0, 0};  // States for 4 LEDs (0 = OFF, 1 = ON)
    int switch_last_state[4] = {1, 1, 1, 1};  // Last state of each switch (1 = not pressed, 0 = pressed)

    while (1)
    {
        // Read the button states (active-low)
        uint16_t switch1_pressed = (*GPIOB_IDR & (1 << 7)) == 0;  // PB7
        uint16_t switch2_pressed = (*GPIOB_IDR & (1 << 3)) == 0;  // PB3
        uint16_t switch3_pressed = (*GPIOB_IDR & (1 << 4)) == 0;  // PB4
        uint16_t switch4_pressed = (*GPIOA_IDR & (1 << 15)) == 0; // PA15

        // Edge detection and debounce for switch 1 (PB7)
        if (switch1_pressed && switch_last_state[0] == 1) {
            led_state[0] ^= 1;  // Toggle LED 1 (PC6)
            switch_last_state[0] = 0;  // Update the last state to pressed
            delay(50000);  // Debounce delay
        } else if (!switch1_pressed) {
            switch_last_state[0] = 1;  // Update the last state to not pressed
        }

        // Edge detection and debounce for switch 2 (PB3)
        if (switch2_pressed && switch_last_state[1] == 1) {
            led_state[1] ^= 1;  // Toggle LED 2 (PB13)
            switch_last_state[1] = 0;  // Update the last state to pressed
            delay(50000);  // Debounce delay
        } else if (!switch2_pressed) {
            switch_last_state[1] = 1;  // Update the last state to not pressed
        }

        // Edge detection and debounce for switch 3 (PB4)
        if (switch3_pressed && switch_last_state[2] == 1) {
            led_state[2] ^= 1;  // Toggle LED 3 (PB14)
            switch_last_state[2] = 0;  // Update the last state to pressed
            delay(50000);  // Debounce delay
        } else if (!switch3_pressed) {
            switch_last_state[2] = 1;  // Update the last state to not pressed
        }

        // Edge detection and debounce for switch 4 (PA15)
        if (switch4_pressed && switch_last_state[3] == 1) {
            led_state[3] ^= 1;  // Toggle LED 4 (PB15)
            switch_last_state[3] = 0;  // Update the last state to pressed
            delay(50000);  // Debounce delay
        } else if (!switch4_pressed) {
            switch_last_state[3] = 1;  // Update the last state to not pressed
        }

        // Update LEDs based on their states
        if (led_state[0] == 1)
            *GPIOC_ODR &= ~(1 << 6); // Turn ON LED 1 (PC6)
        else
            *GPIOC_ODR |= (1 << 6);  // Turn OFF LED 1 (PC6)

        if (led_state[1] == 1)
            *GPIOB_ODR &= ~(1 << 13); // Turn ON LED 2 (PB13)
        else
            *GPIOB_ODR |= (1 << 13);  // Turn OFF LED 2 (PB13)

        if (led_state[2] == 1)
            *GPIOB_ODR &= ~(1 << 14); // Turn ON LED 3 (PB14)
        else
            *GPIOB_ODR |= (1 << 14);  // Turn OFF LED 3 (PB14)

        if (led_state[3] == 1)
            *GPIOB_ODR &= ~(1 << 15); // Turn ON LED 4 (PB15)
        else
            *GPIOB_ODR |= (1 << 15);  // Turn OFF LED 4 (PB15)
    }
}
