/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint32_t *RCC_AHB1ENR = (uint32_t*)0x40023830;

uint32_t *GPIOC_MODER = (uint32_t*)0x40020800;
uint32_t *GPIOC_ODR = (uint32_t*)0x40020814;

uint32_t *GPIOB_MODER = (uint32_t*)0x40020400;
uint32_t *GPIOB_ODR = (uint32_t*)0x40020414;

uint32_t *GPIOA_MODER = (uint32_t*)0x40020000;
uint32_t *GPIOA_IDR = (uint32_t*)0x40020010;

uint16_t current_st=0, last_st=1, count=0;
uint16_t pinStatus;
/*current_st: Stores the current state of a pin (read from GPIOA).
last_st: Stores the last state of the pin (used to detect a change in state).
count: Keeps track of how many times the input has toggled (used in the state machine).
pinStatus: Unused in the code provided.*/

int main(void)
{

    *RCC_AHB1ENR |=(7<<0);// Enables GPIOA, GPIOB, and GPIOC clock (binary 111 -> 7)

    *GPIOC_MODER |=(1<<12);// // Set GPIOC pin 6 as output (binary 01)
    *GPIOC_MODER &=~(1<<13);

    *GPIOB_MODER |=(1<<26);
    *GPIOB_MODER &=~(1<<27);

    *GPIOB_MODER |=(1<<28);
    *GPIOB_MODER &=~(1<<29);

    *GPIOB_MODER |=(1<<30);
    *GPIOB_MODER &=~(1<<31);

    *GPIOA_MODER &=~(3<<30);  // PA15

    *GPIOC_ODR |=(1<<6);
    *GPIOB_ODR |=(1<<13);
    *GPIOB_ODR |=(1<<14);
    *GPIOB_ODR |=(1<<15);


    while(1)
    {//Detecting Button Press (GPIOA pin 15):
    	current_st = (*GPIOA_IDR >> 15) & 1;
    	if(current_st != last_st)
    	{
    		current_st = (*GPIOA_IDR >> 15)& 1;
    		if(current_st==0)
    		{
    			if(count>6)
    			  count=0;
    			count=count+1;
    		}
    		last_st = current_st;
    	}

    	if(count>0)
    	{
    		switch(count)
    		{
    		case 1: *GPIOC_ODR ^=(1<<6);//  Toggle GPIOC pin 6
    		         for(uint32_t i=0;i<5000;i++);
    		         break;

    		case 2: *GPIOC_ODR |=(1<<6);// Set GPIOC pin 6 high
    		        *GPIOB_ODR ^=(1<<13);// Toggle GPIOB pin 13
    		         for(uint32_t i=0; i<5000;i++);
    		         break;

    		case 3: *GPIOB_ODR |=(1<<13);
    		        *GPIOB_ODR ^=(1<<14);
    		         for(uint32_t i=0; i<5000;i++);
    		         break;

    		case 4: *GPIOB_ODR |=(1<<14);
					*GPIOB_ODR ^=(1<<15);
					 for(uint32_t i=0; i<5000;i++);
					 break;

    		case 5: *GPIOC_ODR ^=(1<<6);
    				*GPIOB_ODR ^=(1<<13);
    				*GPIOB_ODR ^=(1<<14);
    				*GPIOB_ODR ^=(1<<15);
    				 for(uint32_t i=0; i<100000;i++);
    	             break;

    		case 6: *GPIOC_ODR &=~(1<<6);
					*GPIOB_ODR &=~(1<<13);
					*GPIOB_ODR &=~(1<<14);
					*GPIOB_ODR &=~(1<<15);
					 for(uint32_t i=0; i<5000;i++);
					 break;

    		case 7: *GPIOC_ODR |=(1<<6);//// Toggle GPIOB pin 13
					*GPIOB_ODR |=(1<<13);
					*GPIOB_ODR |=(1<<14);
					*GPIOB_ODR |=(1<<15);
					 for(uint32_t i=0; i<5000;i++);
					 break;
    		}
    	}
    }
	return 0;
}
