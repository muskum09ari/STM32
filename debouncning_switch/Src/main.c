/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>  // Include this to use uint32_t, uint8_t, etc.

// Define the register addresses
uint32_t *clockreg = (uint32_t*)0x40023830;  // RCC AHB1 peripheral clock enable register
uint32_t *moderregC = (uint32_t*)0x40020800; // GPIOC Mode Register
uint32_t *moderregB = (uint32_t*)0x40020400; // GPIOB Mode Register
uint32_t *moderregA = (uint32_t*)0x40020000; // GPIOA Mode Register
uint32_t *odrregC = (uint32_t*)0x40020814;    // GPIOC Output Data Register (for LEDs)
uint32_t *odrregB = (uint32_t*)0x40020414;    // GPIOB Output Data Register (for LEDs)
uint32_t *odrregA = (uint32_t*)0x40020014;    // GPIOA Output Data Register (for SW4)
uint32_t *idrregA = (uint32_t*)0x40020010;    // GPIOA Input Data Register (for SW4)

// Function to add a small delay
void delay(volatile uint32_t time)
{
    while (time--);
}

// Function to detect rising edge of the button press (SW4)
uint8_t is_button_pressed(void)
{
    static uint8_t last_state = 1;  // Assume the button is not pressed initially
    uint8_t current_state = (*idrregA & (1 << 15)) == 0;  // Button is pressed (active low)

    // Rising edge detection: button pressed now, but wasn't pressed last time
    if (current_state == 1 && last_state == 0)
    {
        last_state = current_state;
        return 1;  // Button pressed
    }

    last_state = current_state;
    return 0;  // No button press
}

int main(void)
{
    // Step 1: Enable clock for GPIOA, GPIOB, and GPIOC
    *clockreg |= (1 << 2);  // Enable GPIOC clock (bit 2)
    *clockreg |= (1 << 1);  // Enable GPIOB clock (bit 1)
    *clockreg |= (1 << 0);  // Enable GPIOA clock (bit 0)

    // Step 2: Configure LED1 (PC6), LED2 (PB13), LED3 (PB14), LED4 (PB15) as output
    *moderregC |= (1 << 12);   // Set PC6 to output mode (LED1)
    *moderregC &= ~(1 << 13);  // Clear second bit for PC6
    *moderregB |= (1 << 26);   // Set PB13 to output mode (LED2)
    *moderregB &= ~(1 << 27);  // Clear second bit for PB13
    *moderregB |= (1 << 28);   // Set PB14 to output mode (LED3)
    *moderregB &= ~(1 << 29);  // Clear second bit for PB14
    *moderregB |= (1 << 30);   // Set PB15 to output mode (LED4)
    *moderregB &= ~(1 << 31);  // Clear second bit for PB15

    // Step 3: Configure SW4 (PA15) as input (already done)
    *moderregA &= ~(3 << (2 * 15));  // Set PA15 as input (SW4)

    uint8_t press_count = 0;  // Counts the number of presses of SW4

    // Step 4: Main loop to detect button press and toggle LEDs
    while (1)
    {
        // Check if button (SW4) is pressed (rising edge detection)
        if (is_button_pressed())
        {
            press_count++;

            // Perform actions based on the number of presses
            if (press_count == 1)
            {
                // Turn ON LED1 and OFF all others
                *odrregC &= ~(1 << 6);  // Turn on LED1 (PC6) - active low
                *odrregB |= (1 << 13);  // Turn off LED2 (PB13)
                *odrregB |= (1 << 14);  // Turn off LED3 (PB14)
                *odrregB |= (1 << 15);  // Turn off LED4 (PB15)
            }
            else if (press_count == 2)
            {
                // Turn OFF LED1 and turn ON LED2
                *odrregC |= (1 << 6);   // Turn off LED1 (PC6)
                *odrregB &= ~(1 << 13); // Turn on LED2 (PB13)
                *odrregB |= (1 << 14);  // Turn off LED3 (PB14)
                *odrregB |= (1 << 15);  // Turn off LED4 (PB15)
            }
            else if (press_count == 3)
            {
                // Turn OFF LED2 and turn ON LED3
                *odrregB |= (1 << 13);  // Turn off LED2 (PB13)
                *odrregB &= ~(1 << 14); // Turn on LED3 (PB14)
                *odrregB |= (1 << 15);  // Turn off LED4 (PB15)
            }
            else if (press_count == 4)
            {
                // Turn OFF LED3 and turn ON LED4
                *odrregB |= (1 << 14);  // Turn off LED3 (PB14)
                *odrregB &= ~(1 << 15); // Turn on LED4 (PB15)
            }
            else if (press_count == 5)
            {
                // Turn OFF all LEDs
                *odrregC |= (1 << 6);   // Turn off LED1 (PC6)
                *odrregB |= (1 << 13);  // Turn off LED2 (PB13)
                *odrregB |= (1 << 14);  // Turn off LED3 (PB14)
                *odrregB |= (1 << 15);  // Turn off LED4 (PB15)
            }
            else if (press_count == 6)
            {
                // Turn ON all LEDs
                *odrregC &= ~(1 << 6);  // Turn on LED1 (PC6)
                *odrregB &= ~(1 << 13); // Turn on LED2 (PB13)
                *odrregB &= ~(1 << 14); // Turn on LED3 (PB14)
                *odrregB &= ~(1 << 15); // Turn on LED4 (PB15)
            }
            else if (press_count == 7)
            {
                // Toggle all LEDs
                *odrregC ^= (1 << 6);   // Toggle LED1 (PC6)
                *odrregB ^= (1 << 13);  // Toggle LED2 (PB13)
                *odrregB ^= (1 << 14);  // Toggle LED3 (PB14)
                *odrregB ^= (1 << 15);  // Toggle LED4 (PB15)

                press_count = 0;  // Reset press count after toggling
            }

            // Optional: Small delay for debouncing
            delay(100000);  // Adjust delay for debouncing effect
        }
    }
}


