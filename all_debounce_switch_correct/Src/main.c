/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>


uint32_t *RCC_AHB1ENR = (uint32_t*)0x40023830;

uint32_t *GPIOB_MODER = (uint32_t*)0x40020400;

uint32_t *GPIOB_IDR = (uint32_t*)0x40020410;

uint32_t *GPIOC_MODER = (uint32_t*)0x40020800;

uint32_t *GPIOC_ODR = (uint32_t*)0x40020814;

uint32_t *GPIOB_ODR = (uint32_t*)0x40020414;

uint32_t *GPIOA_MODER = (uint32_t*)0x40020000;

uint32_t *GPIOA_IDR = (uint32_t*)0x40020010;


int main(void)

{

    *RCC_AHB1ENR |= (1 << 2); // Enable clock for GPIOC

    *RCC_AHB1ENR |= (1 << 1); // Enable clock for GPIOB

    // Configure PC6 as output (LED)

    *GPIOC_MODER |= (1 << 12); // Set bit 12 to 1 (output mode for PC6)

    *GPIOC_MODER &= ~(1 << 13); // Set bit 13 to 0 (output mode for PC6)

    // Configure PB7 as input (Switch)

    *GPIOB_MODER &= ~(3 << 14); // Clear bits for PB7 (input mode)

    *GPIOB_MODER |=(1<<26);

    *GPIOB_MODER &=~(1<<27);

    *GPIOB_MODER &=~(3<<6);

    *GPIOB_MODER |=(1<<28);

    *GPIOB_MODER &=~(1<<29);

    *GPIOB_MODER &=~(3<<8); //sw3

    *GPIOB_MODER |=(1<<30);

    *GPIOB_MODER &=~(1<<31);

    *RCC_AHB1ENR |=(1<<0);

    *GPIOA_MODER &=~(3<<30);//SWITCH I|P 4


    uint8_t ledState = 0; // Variable to track the LED state (0 = off, 1 = on)

    uint8_t lastButtonState = 1; // Variable to detect button press (1 = not pressed, 0 = pressed)

    uint8_t lastButtonState2 = 1;

    uint8_t ledState2 = 0;

    uint8_t ledState3 = 0; // Variable to track the LED state (0 = off, 1 = on)

    uint8_t lastButtonState3 = 1; // Variable to detect button press (1 = not pressed, 0 = pressed)

    uint8_t ledState4 = 0; // Variable to track the LED state (0 = off, 1 = on)

    uint8_t lastButtonState4 = 1; // Variable to detect button press (1 = not pressed, 0 = pressed)


    while(1)

    {

        // Read the button status (Switch 1)

        uint8_t buttonStatus = (uint8_t)(*GPIOB_IDR & (1 << 7)) == 0; // Button pressed when PB7 is low

        if (buttonStatus == 0 && lastButtonState == 1) // Detect button press (falling edge)

        {

            // Toggle LED state

            if (ledState == 0) {

                *GPIOC_ODR &= ~(1 << 6); // Turn LED on (set PC6 low)

                ledState = 1; // LED is on

            } else {

                *GPIOC_ODR |= (1 << 6); // Turn LED off (set PC6 high)

                ledState = 0; // LED is off

            }


        }

        lastButtonState = buttonStatus; // Update the last button state

        uint8_t buttonStatus2 = (uint8_t)(*GPIOB_IDR & (1 << 3)) == 0; // Button pressed when PB7 is low

               if (buttonStatus2 == 0 && lastButtonState2 == 1) // Detect button press (falling edge)

               {

                   // Toggle LED state

                   if (ledState2 == 0) {

                       *GPIOB_ODR &= ~(1 << 13); // Turn LED on (set PC6 low)

                       ledState2 = 1; // LED is on

                   } else {

                       *GPIOB_ODR |= (1 << 13); // Turn LED off (set PC6 high)

                       ledState2 = 0; // LED is off

                   }


               }

               lastButtonState2 = buttonStatus2; // Update the last button state

               uint8_t buttonStatus3 = (uint8_t)(*GPIOB_IDR & (1 << 4)) == 0; // Button pressed when PB7 is low

                              if (buttonStatus3 == 0 && lastButtonState3 == 1) // Detect button press (falling edge)

                              {

                                  // Toggle LED state

                                  if (ledState3 == 0) {

                                      *GPIOB_ODR &= ~(1 << 14); // Turn LED on (set PC6 low)

                                      ledState3 = 1; // LED is on

                                  } else {

                                      *GPIOB_ODR |= (1 << 14); // Turn LED off (set PC6 high)

                                      ledState3 = 0; // LED is off

                                  }


                              }

                   lastButtonState3 = buttonStatus3; // Update the last button state

                     uint32_t buttonStatus4 = (uint32_t)(*GPIOA_IDR & (1 << 15)) == 0; // Button pressed when PB7 is low

                          if (buttonStatus4 == 0 && lastButtonState4 == 1) // Detect button press (falling edge)

                             {

                                   // Toggle LED state

                                   if (ledState4 == 0) {

                                    *GPIOB_ODR &= ~(1 << 15); // Turn LED on (set PC6 low)

                                        ledState4 = 1; // LED is on

                                         }
                                   else {

                                        *GPIOB_ODR |= (1 << 15); // Turn LED off (set PC6 high)

                                         ledState4 = 0; // LED is off

                                           }


                                      }

                       lastButtonState4 = buttonStatus4; // Update the last button state


    }

}

/*#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#endif

// RCC register (peripheral clock enable)
uint32_t *RCC_AHB1ENR = (uint32_t*)0x40023830;// SETTING rcc

// GPIOC registers (for LED)
uint32_t *GPIOC_MODER = (uint32_t*)0x40020800;  // GPIOC Mode Register
uint32_t *GPIOC_ODR = (uint32_t*)0x40020814;    // GPIOC Output Data Register

// GPIOB registers (for Switches)
uint32_t *GPIOB_IDR = (uint32_t*)0x40020410;    // GPIOB Input Data Register switch
uint32_t *GPIOB_ODR = (uint32_t*)0x40020414; // GPIOB (led) Configuration: //offeset added
uint32_t *GPIOB_MODER = (uint32_t*)0x40020400;  // GPIOB Mode Register

// GPIOA registers (for Switches)
uint32_t *GPIOA_MODER =(uint32_t*)0x40020000;
uint32_t *GPIOA_IDR = (uint32_t*)0x40020010;    // GPIOA Input Data Register

int main(void)
{
    // Enable GPIOB and GPIOC clocks
    *RCC_AHB1ENR |= (1 << 2);  // Enable GPIOC clock (for LED)
    *RCC_AHB1ENR |= (1 << 1);  // Enable GPIOB clock (for Switches)
    *RCC_AHB1ENR |= (1 << 0);  // Enable GPIOB clock (for Switches)


    // Configure PC6, PB13, PB14, PB15 as output for LEDs
    *GPIOC_MODER |= (1 << 12);  // Set PC6 to output mode
    *GPIOC_MODER &= ~(1 << 13); // Clear bit 13 to configure PC6 as output

    *GPIOB_MODER |= (1 << 26);  // Set PB13 to output mode
    *GPIOB_MODER &= ~(1 << 27); // Clear bit 27 to configure PB13 as output

    *GPIOB_MODER |= (1 << 28);  // Set PB14 to output mode
    *GPIOB_MODER &= ~(1 << 29); // Clear bit 29 to configure PB14 as output

    *GPIOB_MODER |= (1 << 30);  // Set PB15 to output mode
    *GPIOB_MODER &= ~(1 << 31); // Clear bit 31 to configure PB15 as output

    // Configure PB7, PB3, PB4, PA15 as input for switches
    *GPIOB_MODER &= ~(3 << 14); // Set PB7 to input mode
    *GPIOB_MODER &= ~(3 << 6);  // Set PB3 to input mode
    *GPIOB_MODER &= ~(3 << 8);  // Set PB4 to input mode
    *GPIOA_MODER &=~(3 << 30); // Set PA15 to input mode

    // Initial LED state (all OFF)
    *GPIOC_ODR &= ~(1 << 6);  // LED 1 OFF (PC6)
    *GPIOB_ODR &= ~(1 << 13); // LED 2 OFF (PB13)
    *GPIOB_ODR &= ~(1 << 14); // LED 3 OFF (PB14)
    *GPIOB_ODR &= ~(1 << 15); // LED 4 OFF (PB15)

    int state[4] = {0, 0, 0, 0};  // States for the 4 LEDs

    while(1)
    {
        // Read the button states (active-low)
        uint16_t switch1_pressed = (*GPIOB_IDR & (1 << 7)) == 0;  // PB7
        uint16_t switch2_pressed = (*GPIOB_IDR & (1 << 3)) == 0;  // PB3
        uint16_t switch3_pressed = (*GPIOB_IDR & (1 << 4)) == 0;  // PB4
        uint16_t switch4_pressed = (*GPIOA_IDR & (1 << 15)) == 0; // PA15

        // Toggle logic for each LED based on the switch press
        if (switch1_pressed)
        {
            state[0] ^= 1;  // Toggle state for LED 1
        }
        if (switch2_pressed)
        {
            state[1] ^= 1;  // Toggle state for LED 2
        }
        if (switch3_pressed)
        {
            state[2] ^= 1;  // Toggle state for LED 3
        }
        if (switch4_pressed)
        {
            state[3] ^= 1;  // Toggle state for LED 4
        }

        // Update LEDs based on their states
        if (state[0] == 1)
            *GPIOC_ODR &= ~(1 << 6); // Turn ON LED 1 (PC6)
        else
            *GPIOC_ODR |= (1 << 6);  // Turn OFF LED 1 (PC6)

        if (state[1] == 1)
            *GPIOB_ODR &= ~(1 << 13); // Turn ON LED 2 (PB13)
        else
            *GPIOB_ODR |= (1 << 13);  // Turn OFF LED 2 (PB13)

        if (state[2] == 1)
            *GPIOB_ODR &= ~(1 << 14); // Turn ON LED 3 (PB14)
        else
            *GPIOB_ODR |= (1 << 14);  // Turn OFF LED 3 (PB14)

        if (state[3] == 1)
            *GPIOB_ODR &= ~(1 << 15); // Turn ON LED 4 (PB15)
        else
            *GPIOB_ODR |= (1 << 15);  // Turn OFF LED 4 (PB15)
    }

}*/
